canvas {
    width = 1000.
    height = 600.

    shape box = Rectangle {
        w: width
        h: height

        center: (0., 0.)

        strokeColor: rgba(0., 0., 0., 1.)
        strokeWidth: 3.

        color: rgba(1., 1., 1., 1.)
    }
}

Object o {

    naturalLength = 150.
    o.tensorRank = 1.
    o.tensorImbalance = 0.

    -- o.leftAttached = false
    -- o.rightAttached = false

    shape o.shape = Line {
        -- start: (0., ?)
        -- end: (canvas.width, ?)

        color: rgba(0., 0., 0., 1.)
        thickness: 5.
    }

    o.shape above canvas.box

    -- ensure contains(canvas.box, o.shape)
    
    ensure equal(o.shape.start[1], o.shape.end[1]) -- ensure lines are horizontal
    ensure lessThan(o.shape.start[0], o.shape.end[0]) -- ensure lines move from left to right

    encourage lengthNear(o.shape, naturalLength)
}

Morphism m {
    -- morphism should all be roughly congruent (higher priority than horizontality of objects)
    shape m.shape = Rectangle {
        w: 100.
        h: 300.

        strokeColor: rgba(0., 0., 0., 1.)
        strokeWidth: 3.
    }

    shape m.text = Text {
        center: m.shape.center
        string: m.label
        fontSize: "30pt"
    }

    m.text above m.shape
    m.shape above canvas.box

    ensure contains(canvas.box, m.shape)
    -- ensure contains(m.shape, m.text) -- keep label inside box
}

Object o; Morphism m {
    ensure disjoint(m.shape, o.shape, 30.) -- as long as a free object line is forced to extend to the left/right of the canvas, this will require that o.shape is at least 30px from the top/bottom of the morphism
}

Object o 
where o := tensor(a, b) 
with Object a; Object b {
    override o.tensorRank = a.tensorRank + b.tensorRank
    override o.tensorImbalance = b.tensorRank - a.tensorRank

    override o.shape.color = rgba(0., 0., 0., 0.2)
    override o.shape.style = "dashed"

    override a.shape.start = o.shape.start + (0., 50.*a.tensorRank)
    -- component version gives "Cannot read property 'tag' of undefined"
    -- override a.shape.start[0] = o.shape.start[0]
    -- override a.shape.start[1] = o.shape.start[1] + 50.*a.tensorRank
    override b.shape.start = o.shape.start + (0., -50.*b.tensorRank)
    override a.shape.end = o.shape.end + (0., 50.*a.tensorRank)
    override b.shape.end = o.shape.end + (0., -50.*b.tensorRank)
}

Morphism m
where m := join(a, b)
with Object a; Object b {
    -- attach objects to morphism

    override a.shape.end = m.shape.center + (-m.shape.w/2., 50.*a.tensorImbalance)
    override b.shape.start = m.shape.center + (m.shape.w/2., 50.*b.tensorImbalance)

    -- ensure touchesLeftSide(a.shape, m.shape)

    -- override a.rightAttached = true
    -- override b.leftAttached = true
}