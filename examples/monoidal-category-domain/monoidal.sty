canvas {
    width = 1000.
    height = 600.

    shape box = Rectangle {
        w: width
        h: height

        center: (0., 0.)

        strokeColor: rgba(0., 0., 0., 1.)
        strokeWidth: 3.

        color: rgba(1., 1., 1., 1.)
    }
}

Object o {

    naturalLength = 150.
    o.tensorRank = 1.
    o.tensorImbalance = 0.

    o.left = -canvas.width/2.
    o.right = canvas.width/2.

    o.minY = -canvas.height/2.
    o.maxY = canvas.height/2.

    shape o.shape = Line {
        -- start: (0., ?)
        -- end: (canvas.width, ?)

        color: rgba(0., 0., 0., 1.)
        thickness: 5.
    }

    o.shape above canvas.box

    -- ensure contains(canvas.box, o.shape)
    
    ensure equal(o.shape.start[1], o.shape.end[1]) -- lines are horizontal
    ensure lessThan(o.shape.start[0], o.shape.end[0]) -- lines move from left to right

    ensure equal(o.shape.start[0], o.left) -- once vec2s are fixed, don't use optimizer for this
    ensure equal(o.shape.end[0], o.right)

    ensure lessThan(o.shape.start[1], o.maxY, 30.)
    ensure lessThan(o.minY, o.shape.start[1], 30.)

    -- encourage lengthNear(o.shape, naturalLength)
}

Morphism m {
    -- morphism should all be roughly congruent (higher priority than horizontality of objects)
    shape m.shape = Rectangle {
        w: 100.
        h: 300.

        strokeColor: rgba(0., 0., 0., 1.)
        strokeWidth: 3.
    }

    shape m.text = Text {
        center: m.shape.center
        string: m.label
        fontSize: "30pt"
    }

    m.text above m.shape
    m.shape above canvas.box

    ensure contains(canvas.box, m.shape)
    -- ensure contains(m.shape, m.text) -- keep label inside box
}

Object o; Morphism m {
    ensure disjoint(m.shape, o.shape, 10.) -- as long as a free object line is forced to extend to the left/right of the canvas, this will require that o.shape is at least 10px from the top/bottom of the morphism
}

Object o 
where o := tensor(a, b) 
with Object a; Object b {
    override o.tensorRank = a.tensorRank + b.tensorRank
    override o.tensorImbalance = b.tensorRank - a.tensorRank

    override o.shape.color = rgba(0., 0., 0., 0.2)
    override o.shape.style = "dashed"

    override a.left = o.left
    override b.left = o.left
    override a.right = o.right
    override b.right = o.right
    override a.minY = o.minY
    override b.minY = o.minY
    override a.maxY = o.maxY
    override b.maxY = o.maxY

    ensure lessThan(a.shape.start[1], b.shape.start[1], 30.)

    encourage equal(a.shape.start[1], o.shape.start[1] - 50.*a.tensorRank)
    encourage equal(b.shape.start[1], o.shape.start[1] + 50.*b.tensorRank)

    -- override a.shape.start = o.shape.start + (0., 50.*a.tensorRank)
    -- -- component version gives "Cannot read property 'tag' of undefined"
    -- -- override a.shape.start[0] = o.shape.start[0]
    -- -- override a.shape.start[1] = o.shape.start[1] + 50.*a.tensorRank
    -- override b.shape.start = o.shape.start + (0., -50.*b.tensorRank)
    -- override a.shape.end = o.shape.end + (0., 50.*a.tensorRank)
    -- override b.shape.end = o.shape.end + (0., -50.*b.tensorRank)
}

Morphism m
where m := join(a, b)
with Object a; Object b {
    -- attach objects to morphism

    override a.right = m.shape.center[0] - m.shape.w/2.
    override b.left = m.shape.center[0] + m.shape.w/2.

    override a.minY = m.shape.center[1] - m.shape.h/2.
    override a.maxY = m.shape.center[1] + m.shape.h/2.

    override b.minY = m.shape.center[1] - m.shape.h/2.
    override b.maxY = m.shape.center[1] + m.shape.h/2.

    encourage equal(a.shape.start[1], m.shape.center[1] - 50.*a.tensorImbalance)
    encourage equal(b.shape.start[1], m.shape.center[1] - 50.*b.tensorImbalance)
}